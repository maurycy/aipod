#!/bin/sh

# aipod - container management script
# style inspired by https://get.chezmoi.io

set -e

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/aipod"
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/aipod"
MOUNTS_FILE="${CONFIG_DIR}/mounts"
PORTS_FILE="${CONFIG_DIR}/ports"

# Defaults (set after config is loaded)
IMAGE_NAME=""
CONTAINER_NAME=""
USERNAME=""
CHEZMOI_DOTFILES_REPO=""
USE_RUST="true"
USE_NPM="true"
USE_UV="true"
USE_CLAUDE_CODE="true"
USE_CODEX="true"
CONTAINERFILE=""

usage() {
	cat <<EOF
aipod: manage development containers

Usage: aipod [command] [options]

Commands:
    up          Start container interactively (default if no command given)
    down        Stop the container
    status      Show container status
    clean       Remove container, image, and config

    run         Run command in container
    cp          Copy file/directory to container

    mount       Add volume mount
    unmount     Remove volume mount
    port        Expose container port
    close       Remove port mapping

    config      Edit aipod.conf
    help        Show this help

Mounting directories:
    aipod mount                     Mount current directory to home
    aipod mount <path>              Mount path to home/basename
    aipod mount <path> <remote>     Mount path to specified container path
    aipod unmount                   Remove all mounts
    aipod unmount <path>            Remove mount for specified path

Port usage:
    aipod port <port>               Expose container port to same host port
    aipod port <port> <host>        Expose container port to specified host port
    aipod close <port>              Remove port mapping for container port
    aipod close                     Remove all port mappings

Run usage:
    aipod run <command> [args...]   Run command in container at translated CWD

Copying:
    aipod cp <file|directory>       Copy file/directory to container
EOF
	exit 0
}

log_info() {
	printf 'info %s\n' "$*" 1>&2
}

log_err() {
	printf 'error %s\n' "$*" 1>&2
}

log_crit() {
	printf 'critical %s\n' "$*" 1>&2
}

is_command() {
	type "$1" >/dev/null 2>&1
}

# Find config directory containing aipod.conf
# Checks script directory first (for development), then XDG config directory
find_config_dir() {
	script_dir="$(cd "$(dirname "$0")" && pwd)"
	if [ -f "${script_dir}/aipod.conf" ]; then
		printf '%s' "${script_dir}"
		return 0
	fi
	if [ -f "${CONFIG_DIR}/aipod.conf" ]; then
		printf '%s' "${CONFIG_DIR}"
		return 0
	fi
	# No config found, return config directory as default
	printf '%s' "${CONFIG_DIR}"
}

load_config() {
	config_dir="$(find_config_dir)"
	if [ -f "${config_dir}/aipod.conf" ]; then
		# shellcheck disable=SC1091
		. "${config_dir}/aipod.conf"
	fi
	# Apply defaults - HOSTNAME from config becomes CONTAINER_NAME and IMAGE_NAME
	CONTAINER_NAME="${HOSTNAME:-aipod}"
	IMAGE_NAME="${HOSTNAME:-aipod}"
	USERNAME="${USERNAME:-developer}"

	# Resolve CONTAINERFILE: config value, or search DATA_DIR
	if [ -n "${CONTAINERFILE}" ]; then
		case "${CONTAINERFILE}" in
			/*)
				;;
			*)
                if [ -f "${DATA_DIR}/${CONTAINERFILE}" ]; then
					CONTAINERFILE="${DATA_DIR}/${CONTAINERFILE}"
				fi
				;;
			esac
	else
		script_dir="$(cd "$(dirname "$0")" && pwd)"
		if [ -f "${script_dir}/Containerfile" ]; then
			CONTAINERFILE="${script_dir}/Containerfile"
		elif [ -f "${DATA_DIR}/Containerfile" ]; then
			CONTAINERFILE="${DATA_DIR}/Containerfile"
		fi
	fi

	# Validate Containerfile exists
	if [ ! -f "${CONTAINERFILE}" ]; then
		log_crit "Containerfile not found: ${CONTAINERFILE:-<not set>}"
		exit 1
	fi
}

ensure_config_dir() {
	if [ ! -d "${CONFIG_DIR}" ]; then
		mkdir -p "${CONFIG_DIR}"
	fi
}

mount_exists() {
	[ -f "${MOUNTS_FILE}" ] || return 1
	awk -F: -v p="$1" '$1==p {found=1} END{exit !found}' "${MOUNTS_FILE}"
}

port_exists() {
	[ -f "${PORTS_FILE}" ] || return 1
	awk -F: -v p="$1" '$2==p {found=1} END{exit !found}' "${PORTS_FILE}"
}

container_exists() {
	podman container exists "${CONTAINER_NAME}" 2>/dev/null
}

container_running() {
	[ "$(podman container inspect -f '{{.State.Running}}' "${CONTAINER_NAME}" 2>/dev/null)" = "true" ]
}

image_exists() {
	podman image exists "${IMAGE_NAME}" 2>/dev/null
}

snapshot_exists() {
	podman image exists "${IMAGE_NAME}:snapshot" 2>/dev/null
}

run_image() {
	if snapshot_exists; then
		printf '%s' "${IMAGE_NAME}:snapshot"
	else
		printf '%s' "${IMAGE_NAME}"
	fi
}

# Translate host path to container path using mounts file
# Returns 0 and prints container path if found, returns 1 if not covered by any mount
# Resolves symlinks on both input path and mount paths for correct matching
host_to_container_path() {
	host_path="$1"
	[ -f "${MOUNTS_FILE}" ] || return 1

	# Resolve symlinks in input path (must be a directory for CWD use case)
	resolved_host="$(cd -P "${host_path}" 2>/dev/null && pwd -P)" || return 1

	while IFS=: read -r local_dir remote_dir; do
		[ -z "${local_dir}" ] && continue

		# Resolve symlinks in mount path
		resolved_local="$(cd -P "${local_dir}" 2>/dev/null && pwd -P)" || continue

		case "${resolved_host}" in
			"${resolved_local}")
				printf '%s\n' "${remote_dir}"
				return 0
				;;
			"${resolved_local}"/*)
				relative="${resolved_host#"${resolved_local}"}"
				printf '%s%s\n' "${remote_dir}" "${relative}"
				return 0
				;;
		esac
	done < "${MOUNTS_FILE}"
	return 1
}

# Ensure container is running (start if needed, create if doesn't exist)
ensure_running() {
	if ! container_exists; then
		cmd_run_headless
	elif ! container_running; then
		log_info "starting container ${CONTAINER_NAME}"
		podman start "${CONTAINER_NAME}" >/dev/null || true
	fi
	if ! container_running; then
		log_err "container ${CONTAINER_NAME} is not running - recreate with 'aipod clean'"
		exit 1
	fi
}

# Start container without opening interactive shell
cmd_run_headless() {
	cmd_build
	set --
	if [ -f "${MOUNTS_FILE}" ]; then
		while IFS= read -r line; do
			[ -z "${line}" ] && continue
			set -- "$@" -v "$line"
		done < "${MOUNTS_FILE}"
	fi
	if [ -f "${PORTS_FILE}" ]; then
		while IFS= read -r line; do
			[ -z "${line}" ] && continue
			set -- "$@" -p "$line"
		done < "${PORTS_FILE}"
	fi
	if container_exists; then
		if ! container_running; then
			podman start "${CONTAINER_NAME}" >/dev/null || true
		fi
	else
		log_info "creating container ${CONTAINER_NAME}"
		podman run -d \
			--replace \
			--hostname "${CONTAINER_NAME}" \
			--name "${CONTAINER_NAME}" \
			"$@" \
			"$(run_image)" \
			tail -f /dev/null
	fi
}

commit_snapshot() {
	if container_exists; then
		log_info "committing container state"
		podman commit --quiet "${CONTAINER_NAME}" "${IMAGE_NAME}:snapshot" >/dev/null
		podman rm -f "${CONTAINER_NAME}" >/dev/null 2>&1 || true
	fi
}

cmd_build() {
	if ! image_exists; then
		log_info "building image ${IMAGE_NAME}"
		podman build \
			--build-arg USERNAME="${USERNAME}" \
			--build-arg CHEZMOI_DOTFILES_REPO="${CHEZMOI_DOTFILES_REPO}" \
			--build-arg USE_RUST="${USE_RUST}" \
			--build-arg USE_NPM="${USE_NPM}" \
			--build-arg USE_UV="${USE_UV}" \
			--build-arg USE_CLAUDE_CODE="${USE_CLAUDE_CODE}" \
			--build-arg USE_CODEX="${USE_CODEX}" \
			-t "${IMAGE_NAME}" \
			-f "${CONTAINERFILE}" \
			"$(dirname "${CONTAINERFILE}")"
	fi
}

cmd_run() {
	cmd_build
	set --
	if [ -f "${MOUNTS_FILE}" ]; then
		while IFS= read -r line; do
			[ -z "${line}" ] && continue
			set -- "$@" -v "$line"
		done < "${MOUNTS_FILE}"
	fi
	if [ -f "${PORTS_FILE}" ]; then
		while IFS= read -r line; do
			[ -z "${line}" ] && continue
			set -- "$@" -p "$line"
		done < "${PORTS_FILE}"
	fi
	if container_exists; then
		if container_running; then
			log_info "opening shell in running container ${CONTAINER_NAME}"
		else
			log_info "starting existing container ${CONTAINER_NAME}"
			podman start "${CONTAINER_NAME}" >/dev/null || true
		fi
	else
		log_info "creating container ${CONTAINER_NAME}"
		podman run -d \
			--replace \
			--hostname "${CONTAINER_NAME}" \
			--name "${CONTAINER_NAME}" \
			"$@" \
			"$(run_image)" \
			tail -f /dev/null
	fi
	if ! container_running; then
		log_err "container ${CONTAINER_NAME} is not running - recreate with 'aipod clean'"
		exit 1
	fi

	cwd="$(pwd -P)"
	container_cwd="$(host_to_container_path "${cwd}" || true)"

	if [ -n "${container_cwd}" ]; then
		podman exec -it -w "${container_cwd}" "${CONTAINER_NAME}" /bin/zsh
	else
		podman exec -it "${CONTAINER_NAME}" /bin/zsh
	fi
}

cmd_down() {
	if container_exists; then
		log_info "stopping container ${CONTAINER_NAME}"
		podman stop "${CONTAINER_NAME}" 2>/dev/null || true
	else
		log_info "container ${CONTAINER_NAME} does not exist"
	fi
}

cmd_clean() {
	log_info "stopping container ${CONTAINER_NAME}"
	podman stop "${CONTAINER_NAME}" 2>/dev/null || true
	log_info "removing container ${CONTAINER_NAME}"
	podman rm "${CONTAINER_NAME}" 2>/dev/null || true
	log_info "removing snapshot image"
	podman rmi "${IMAGE_NAME}:snapshot" 2>/dev/null || true
	log_info "removing image ${IMAGE_NAME}"
	podman rmi "${IMAGE_NAME}" 2>/dev/null || true
	log_info "removing mounts config"
	rm -f "${MOUNTS_FILE}"
	log_info "removing ports config"
	rm -f "${PORTS_FILE}"
}

cmd_exec() {
	if [ $# -eq 0 ]; then
		log_err "usage: aipod run <command> [args...]"
		exit 1
	fi

	ensure_running

	cwd="$(pwd -P)"
	container_cwd="$(host_to_container_path "${cwd}" || true)"

	if [ -n "${container_cwd}" ]; then
		podman exec -it -w "${container_cwd}" "${CONTAINER_NAME}" zsh -ic "$*"
	else
		podman exec -it "${CONTAINER_NAME}" zsh -ic "$*"
	fi
}

cmd_sync() {
	if [ -z "${1:-}" ]; then
		log_err "usage: aipod cp <file|directory>"
		exit 1
	fi

	# Resolve to absolute path
	if [ -d "$1" ]; then
		src="$(cd "$1" && pwd)"
	elif [ -f "$1" ]; then
		src="$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
	else
		log_err "path does not exist: $1"
		exit 1
	fi

	# Get container destination - use mount path if available, else default to home
	container_path="$(host_to_container_path "${src}")" || {
		container_path="/home/${USERNAME}/$(basename "${src}")"
	}

	ensure_running
	log_info "syncing ${src} -> ${container_path}"
	podman cp "${src}" "${CONTAINER_NAME}:${container_path}"
}

cmd_mount() {
	local_path="${1:-$(pwd)}"
	local_path="$(cd "${local_path}" 2>/dev/null && pwd || printf '%s' "${local_path}")"
	basename="$(basename "${local_path}")"
	remote_path="${2:-/home/${USERNAME}/${basename}}"

	# Prevent mounting home directory
	if [ "${local_path}" = "${HOME}" ]; then
		log_err "mounting your home directory is a bad idea, and goes against the purpose of containerization"
		exit 1
	fi

	ensure_config_dir

	# Check if mount already exists
	if mount_exists "${local_path}"; then
		log_info "mount for ${local_path} already exists"
		return 0
	fi

	log_info "mounting ${local_path} to ${remote_path}"
	printf '%s:%s\n' "${local_path}" "${remote_path}" >> "${MOUNTS_FILE}"

	# Recreate container if it exists
	if container_exists; then
		commit_snapshot
		log_info "recreating container with new mount"
		cmd_run
	fi
}

cmd_unmount() {
	if [ ! -f "${MOUNTS_FILE}" ]; then
		log_info "no mounts configured"
		return 0
	fi

	if [ -z "${1:-}" ]; then
		log_info "removing all mounts"
		rm -f "${MOUNTS_FILE}"
	else
		local_path="${1}"
		local_path="$(cd "${local_path}" 2>/dev/null && pwd || printf '%s' "${local_path}")"
		log_info "removing mount for ${local_path}"
		tmp_file="${MOUNTS_FILE}.tmp"
		if awk -F: -v p="${local_path}" '$1!=p' "${MOUNTS_FILE}" > "${tmp_file}"; then
			mv "${tmp_file}" "${MOUNTS_FILE}"
		else
			rm -f "${tmp_file}"
			log_err "failed to update mounts file"
			exit 1
		fi
		# Remove file if empty
		if [ ! -s "${MOUNTS_FILE}" ]; then
			rm -f "${MOUNTS_FILE}"
		fi
	fi

	# Recreate container if it exists
	if container_exists; then
		commit_snapshot
		log_info "recreating container without mount"
		cmd_run
	fi
}

valid_port() {
	case "$1" in
		''|*[!0-9]*) return 1 ;;
	esac
	[ "$1" -ge 1 ] && [ "$1" -le 65535 ]
}

cmd_expose() {
	container_port="${1:-}"
	if [ -z "${container_port}" ]; then
		log_err "usage: aipod expose <port> [host_port]"
		exit 1
	fi
	host_port="${2:-${container_port}}"

	if ! valid_port "${container_port}"; then
		log_err "invalid container port: ${container_port} (must be 1-65535)"
		exit 1
	fi
	if ! valid_port "${host_port}"; then
		log_err "invalid host port: ${host_port} (must be 1-65535)"
		exit 1
	fi

	ensure_config_dir

	# Check if port already exposed
	if port_exists "${container_port}"; then
		log_info "port ${container_port} already exposed"
		return 0
	fi

	log_info "exposing port ${container_port} to host port ${host_port}"
	printf '%s:%s\n' "${host_port}" "${container_port}" >> "${PORTS_FILE}"

	# Recreate container if it exists
	if container_exists; then
		commit_snapshot
		log_info "recreating container with new port"
		cmd_run
	fi
}

cmd_close() {
	if [ ! -f "${PORTS_FILE}" ]; then
		log_info "no ports exposed"
		return 0
	fi

	if [ -z "${1:-}" ]; then
		log_info "removing all port mappings"
		rm -f "${PORTS_FILE}"
	else
		container_port="${1}"
		log_info "closing port ${container_port}"
		tmp_file="${PORTS_FILE}.tmp"
		if awk -F: -v p="${container_port}" '$2!=p' "${PORTS_FILE}" > "${tmp_file}"; then
			mv "${tmp_file}" "${PORTS_FILE}"
		else
			rm -f "${tmp_file}"
			log_err "failed to update ports file"
			exit 1
		fi
		# Remove file if empty
		if [ ! -s "${PORTS_FILE}" ]; then
			rm -f "${PORTS_FILE}"
		fi
	fi

	# Recreate container if it exists
	if container_exists; then
		commit_snapshot
		log_info "recreating container without port"
		cmd_run
	fi
}

cmd_config() {
	editor="${EDITOR:-vi}"
	config_dir="$(find_config_dir)"
	"${editor}" "${config_dir}/aipod.conf"
}

cmd_status() {
	# Container state
	if container_exists; then
		if container_running; then
			printf 'container: running\n'
		else
			printf 'container: stopped\n'
		fi
	else
		printf 'container: not created\n'
	fi

	# Image state
	if image_exists; then
		printf 'image:     %s\n' "${IMAGE_NAME}"
	else
		printf 'image:     not built\n'
	fi

	# Snapshot state
	if snapshot_exists; then
		printf 'snapshot:  %s:snapshot\n' "${IMAGE_NAME}"
	else
		printf 'snapshot:  (none)\n'
	fi

	# Mounts
	printf 'mounts:\n'
	if [ -f "${MOUNTS_FILE}" ]; then
		while IFS= read -r line; do
			[ -z "${line}" ] && continue
			printf '  %s\n' "$line"
		done < "${MOUNTS_FILE}"
	else
		printf '  (none)\n'
	fi

	# Ports
	printf 'ports:\n'
	if [ -f "${PORTS_FILE}" ]; then
		while IFS= read -r line; do
			[ -z "${line}" ] && continue
			printf '  %s\n' "$line"
		done < "${PORTS_FILE}"
	else
		printf '  (none)\n'
	fi
}

main() {
	# Check for podman
	if ! is_command podman; then
		log_crit "podman is not installed - see https://podman.io/docs/installation"
		exit 1
	fi

	# Load configuration
	load_config

	cmd="${1:-}"
	shift 2>/dev/null || true

	case "${cmd}" in
	"" | up | start)
		cmd_run
		;;
	down | stop)
		cmd_down
		;;
	clean | purge)
		cmd_clean
		;;
	run)
		cmd_exec "$@"
		;;
	cp | sync)
		cmd_sync "$@"
		;;
	status | info | ps)
		cmd_status
		;;
	mount)
		cmd_mount "$@"
		;;
	unmount | umount)
		cmd_unmount "$@"
		;;
	port | expose | bind | listen)
		cmd_expose "$@"
		;;
	close | unbind)
		cmd_close "$@"
		;;
	config)
		cmd_config
		;;
	help | usage | -h | --help)
		usage
		;;
	*)
		log_err "unknown command: ${cmd}"
		usage
		;;
	esac
}

main "$@"
